<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Two-Series Connected Scatterplot (D3 v7)</title>
  <style>
    :root {
      --bg: #0b0e14;            /* deep slate */
      --panel: #121723;         /* card */
      --ink: #e6edf3;           /* text */
      --muted: #94a3b8;         /* secondary text */
      --grid: #293041;          /* grid lines */
      --accentA: #60a5fa;       /* blue */
      --accentB: #f472b6;       /* pink */
      --focus: #22d3ee;         /* cyan */
    }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }

    .wrap { max-width: 1024px; margin: 24px auto 56px; padding: 0 16px; }

    .card { background: var(--panel); border: 1px solid #1e2637; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.3); }
    .card header { padding: 16px 18px; border-bottom: 1px solid #1e2637; display: flex; gap: 12px; align-items: center; justify-content: space-between; flex-wrap: wrap; }

    .title { font-size: 18px; font-weight: 650; letter-spacing: .2px; }
    .sub { color: var(--muted); }

    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0f1524; border: 1px solid #1e2637; color: var(--muted); }
    .chip .swatch { width: 10px; height: 10px; border-radius: 999px; display: inline-block; }

    .play { appearance: none; border: 1px solid #1e2637; background: #0f1524; color: var(--ink); padding: 6px 10px; border-radius: 10px; cursor: pointer; }
    .play:hover { border-color: #334155; }

    .range { width: 240px; }
    input[type="range"] { width: 100%; }

    .plot { position: relative; }
    svg { width: 100%; height: auto; display: block; }

    .axis text { fill: var(--muted); font-size: 12px; }
    .axis path, .axis line { stroke: #1e2637; }
    .grid line { stroke: var(--grid); stroke-opacity: .55; shape-rendering: crispEdges; }
    .grid .domain { stroke: none; }

    .lineA { stroke: var(--accentA); }
    .lineB { stroke: var(--accentB); }

    .ptA { fill: var(--accentA); stroke: #0b0e14; stroke-width: 1.5; }
    .ptB { fill: var(--accentB); stroke: #0b0e14; stroke-width: 1.5; }

    .yearTag { position: absolute; top: 10px; right: 14px; background: #0f1524; border: 1px solid #1e2637; color: var(--ink); padding: 6px 10px; border-radius: 999px; font-weight: 600; letter-spacing:.3px; }

    .tooltip { position: absolute; pointer-events: none; background: rgba(10,14,22,.95); color: var(--ink); border: 1px solid #1e2637; padding: 8px 10px; border-radius: 10px; font-size: 12px; box-shadow: 0 6px 20px rgba(0,0,0,.35); }
    .tooltip .row { display: grid; grid-template-columns: auto auto; gap: 8px 12px; align-items: center; }
    .tooltip .dot { width: 8px; height: 8px; border-radius: 999px; display: inline-block; }

    .legend { display:flex; gap:10px; align-items:center; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div>
          <div class="title">Connected Scatterplot — Two Series</div>
          <div class="sub">Use the slider (or play) to scrub through years. Hover to see values.</div>
        </div>
        <div class="controls">
          <div class="chip legend"><span class="swatch" style="background: var(--accentA)"></span>Series A</div>
          <div class="chip legend"><span class="swatch" style="background: var(--accentB)"></span>Series B</div>
          <button class="play" id="btnPlay" aria-label="Play animation">▶ Play</button>
          <div class="chip" style="gap:10px;">
            <strong>Year</strong>
            <div class="range"><input id="yearInput" type="range" min="2004" max="2024" step="1" value="2004"></div>
            <span id="yearLabel">2004</span>
          </div>
        </div>
      </header>
      <div class="plot" id="plot">
        <div class="yearTag" id="yearTag">2004</div>
        <div class="tooltip" id="tooltip" style="display:none"></div>
        <svg id="svg" viewBox="0 0 900 560" aria-labelledby="title desc" role="img">
          <title id="title">Connected Scatterplot showing Series A and Series B across time</title>
          <desc id="desc">Each series connects points by year. Move the slider to highlight a given year.</desc>
        </svg>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // ====== Replace this with your real data ======
  // Each series is an array of {year, x, y}
  const seriesA = [
    {year:2004,x:50,y:40},{year:2006,x:58,y:46},{year:2008,x:62,y:55},{year:2010,x:66,y:63},{year:2012,x:72,y:68},{year:2014,x:78,y:74},{year:2016,x:83,y:80},{year:2018,x:88,y:84},{year:2020,x:92,y:89},{year:2022,x:96,y:94},{year:2024,x:100,y:97}
  ];
  const seriesB = [
    {year:2004,x:40,y:52},{year:2006,x:47,y:55},{year:2008,x:53,y:58},{year:2010,x:61,y:60},{year:2012,x:68,y:65},{year:2014,x:73,y:71},{year:2016,x:79,y:77},{year:2018,x:84,y:80},{year:2020,x:90,y:83},{year:2022,x:95,y:88},{year:2024,x:101,y:90}
  ];

  // If you already have two arrays with matching years, keep going.
  const data = [
    {key: 'Series A', values: seriesA},
    {key: 'Series B', values: seriesB}
  ];

  const margin = {top: 28, right: 28, bottom: 48, left: 64};
  const width = 900 - margin.left - margin.right;
  const height = 560 - margin.top - margin.bottom;

  const svg = d3.select('#svg');
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // Scales (auto from data extents)
  const x = d3.scaleLinear()
    .domain(d3.extent(data.flatMap(d => d.values.map(v => v.x))).map((d,i,a)=> i? d + 5: d - 5))
    .range([0, width]);

  const y = d3.scaleLinear()
    .domain(d3.extent(data.flatMap(d => d.values.map(v => v.y))).map((d,i,a)=> i? d + 5: d - 5))
    .range([height, 0]);

  // Axes
  const xAxis = d3.axisBottom(x).ticks(8).tickSizeOuter(0);
  const yAxis = d3.axisLeft(y).ticks(8).tickSizeOuter(0);

  // Gridlines
  g.append('g')
    .attr('class','grid')
    .attr('transform',`translate(0,${height})`)
    .call(d3.axisBottom(x).ticks(8).tickSize(-height).tickFormat(''));

  g.append('g')
    .attr('class','grid')
    .call(d3.axisLeft(y).ticks(8).tickSize(-width).tickFormat(''));

  g.append('g').attr('class','axis').attr('transform',`translate(0,${height})`).call(xAxis);
  g.append('g').attr('class','axis').call(yAxis);

  // Axis labels
  g.append('text')
    .attr('x', width/2)
    .attr('y', height + 38)
    .attr('text-anchor','middle')
    .attr('fill', '#cbd5e1')
    .text('X value');

  g.append('text')
    .attr('transform','rotate(-90)')
    .attr('x', -height/2)
    .attr('y', -46)
    .attr('text-anchor','middle')
    .attr('fill', '#cbd5e1')
    .text('Y value');

  // Line generator
  const line = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y))
    .curve(d3.curveCatmullRom.alpha(0.5));

  // Draw lines
  g.append('path')
    .datum(seriesA)
    .attr('fill','none')
    .attr('stroke-width',3)
    .attr('class','lineA')
    .attr('d', line);

  g.append('path')
    .datum(seriesB)
    .attr('fill','none')
    .attr('stroke-width',3)
    .attr('class','lineB')
    .attr('d', line);

  // Year dots (one per series, updated dynamically)
  const dotA = g.append('circle').attr('r',5.5).attr('class','ptA').style('filter','drop-shadow(0 1px 1px rgba(0,0,0,.6))');
  const dotB = g.append('circle').attr('r',5.5).attr('class','ptB').style('filter','drop-shadow(0 1px 1px rgba(0,0,0,.6))');

  // Labels near dots
  const labelA = g.append('text').attr('fill','var(--ink)').attr('font-size',12).attr('dy','-0.9em').attr('font-weight',600).style('paint-order','stroke').style('stroke','#0b0e14').style('stroke-width','3px');
  const labelB = g.append('text').attr('fill','var(--ink)').attr('font-size',12).attr('dy','-0.9em').attr('font-weight',600).style('paint-order','stroke').style('stroke','#0b0e14').style('stroke-width','3px');

  // Invisible hit-area for hover tooltip
  const hit = g.append('rect').attr('x',0).attr('y',0).attr('width',width).attr('height',height).attr('fill','transparent');

  // Tooltip
  const tooltip = document.getElementById('tooltip');
  const yearTag = document.getElementById('yearTag');

  const yearInput = document.getElementById('yearInput');
  const yearLabel = document.getElementById('yearLabel');
  const btnPlay = document.getElementById('btnPlay');

  const allYears = [...new Set(seriesA.map(d => d.year).concat(seriesB.map(d => d.year)))].sort((a,b)=>a-b);
  yearInput.min = allYears[0];
  yearInput.max = allYears[allYears.length-1];
  yearInput.value = allYears[0];
  yearLabel.textContent = allYears[0];
  yearTag.textContent = allYears[0];

  function getValueAt(series, year){
    // assumes series has objects with {year,x,y}
    return series.find(d => d.year === year);
  }

  function updateYear(year){
    const a = getValueAt(seriesA, year);
    const b = getValueAt(seriesB, year);
    if(!a || !b) return;

    dotA.attr('cx', x(a.x)).attr('cy', y(a.y));
    dotB.attr('cx', x(b.x)).attr('cy', y(b.y));

    labelA.attr('x', x(a.x)).attr('y', y(a.y)).text(`A: ${a.x.toFixed(1)}, ${a.y.toFixed(1)}`);
    labelB.attr('x', x(b.x)).attr('y', y(b.y)).text(`B: ${b.x.toFixed(1)}, ${b.y.toFixed(1)}`);

    yearLabel.textContent = year.toString();
    yearTag.textContent = year.toString();
  }

  updateYear(+yearInput.value);

  // Slider interaction
  yearInput.addEventListener('input', e => updateYear(+e.target.value));

  // Hover interaction: snap to nearest year by nearest point on either series
  hit.on('mousemove', (event) => {
    const [mx,my] = d3.pointer(event);
    const px = x.invert(mx), py = y.invert(my);
    // find nearest year among all points by Euclidean distance in data space
    let best = null;
    for(const yr of allYears){
      const a = getValueAt(seriesA, yr), b = getValueAt(seriesB, yr);
      if(!a || !b) continue;
      const da = (a.x-px)**2 + (a.y-py)**2;
      const db = (b.x-px)**2 + (b.y-py)**2;
      const d = Math.min(da, db);
      if(best === null || d < best.d){ best = {yr, d}; }
    }
    if(best){
      yearInput.value = best.yr;
      updateYear(best.yr);
      // tooltip near cursor
      const a = getValueAt(seriesA, best.yr); const b = getValueAt(seriesB, best.yr);
      tooltip.style.display = 'block';
      tooltip.style.left = (event.offsetX + 16) + 'px';
      tooltip.style.top = (event.offsetY + 16) + 'px';
      tooltip.innerHTML = `
        <div class="row"><div>Year</div><div><strong>${best.yr}</strong></div></div>
        <div class="row"><div><span class="dot" style="background: var(--accentA)"></span> Series A</div><div>${a.x.toFixed(1)}, ${a.y.toFixed(1)}</div></div>
        <div class="row"><div><span class="dot" style="background: var(--accentB)"></span> Series B</div><div>${b.x.toFixed(1)}, ${b.y.toFixed(1)}</div></div>`;
    }
  }).on('mouseleave', () => { tooltip.style.display = 'none'; });

  // Simple play/pause animation
  let timer = null;
  function play(){
    btnPlay.textContent = '❚❚ Pause';
    let idx = allYears.indexOf(+yearInput.value);
    timer = d3.interval(()=>{
      idx = (idx + 1) % allYears.length;
      yearInput.value = allYears[idx];
      updateYear(allYears[idx]);
    }, 900);
  }
  function pause(){
    btnPlay.textContent = '▶ Play';
    if(timer){ timer.stop(); timer = null; }
  }
  btnPlay.addEventListener('click', () => {
    if(timer) pause(); else play();
  });

  // Accessibility: keyboard arrows to scrub
  yearInput.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'ArrowDown'){
      e.preventDefault();
      const idx = Math.max(0, allYears.indexOf(+yearInput.value) - 1);
      yearInput.value = allYears[idx];
      updateYear(allYears[idx]);
    } else if(e.key === 'ArrowRight' || e.key === 'ArrowUp'){
      e.preventDefault();
      const idx = Math.min(allYears.length-1, allYears.indexOf(+yearInput.value) + 1);
      yearInput.value = allYears[idx];
      updateYear(allYears[idx]);
    }
  });

  // ====== Helper: swap in your own data quickly ======
  // To use your data, create two arrays like seriesA / seriesB with matching years.
  // Then replace the arrays above, adjust axis labels, and you're good.
  </script>
</body>
</html>
